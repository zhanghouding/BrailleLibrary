package com.sunteam.library;import java.io.File;import java.io.FileOutputStream;import java.io.PrintWriter;import java.io.StringWriter;import java.io.Writer;import java.lang.reflect.Field;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;import java.util.HashMap;import java.util.Locale;import java.util.Map;import org.wlf.filedownloader.FileDownloadConfiguration;import org.wlf.filedownloader.FileDownloadConfiguration.Builder;import org.wlf.filedownloader.FileDownloader;import com.sunteam.library.utils.LibraryConstant;import android.app.Application;import android.content.Context;import android.content.pm.PackageInfo;import android.content.pm.PackageManager;import android.content.pm.PackageManager.NameNotFoundException;import android.os.Build;import android.os.Environment;import android.util.Log;public class InitApplication extends Application  implements Thread.UncaughtExceptionHandler{	private static final String TAG = "InitApplication";		//系统默认的UncaughtException处理类 	private Thread.UncaughtExceptionHandler mDefaultHandler;		//程序的Context对象	private Context mContext;		//用来存储设备信息和异常信息	private Map<String, String> infos = new HashMap<String, String>();	//用于格式化日期,作为日志文件名的一部分	private DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss", Locale.getDefault() );		@Override	public void onCreate() 	{				super.onCreate();		        // 1、创建Builder        Builder builder = new FileDownloadConfiguration.Builder(this);        // 2.配置Builder        // 配置下载文件保存的文件夹        builder.configFileDownloadDir(LibraryConstant.LIBRARY_ROOT_PATH);        // 配置同时下载任务数量，如果不配置默认为2        builder.configDownloadTaskSize(1);        // 配置失败时尝试重试的次数，如果不配置默认为0不尝试        builder.configRetryDownloadTimes(5);        // 开启调试模式，方便查看日志等调试相关，如果不配置默认不开启        builder.configDebugMode(false);        // 配置连接网络超时时间，如果不配置默认为15秒        builder.configConnectTimeout(25000);// 25秒        // 3、使用配置文件初始化FileDownloader        FileDownloadConfiguration configuration = builder.build();        FileDownloader.init(configuration);                mContext = this;		//获取系统默认的UncaughtException处理器		mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();		//设置该CrashHandler为程序的默认处理器		Thread.setDefaultUncaughtExceptionHandler(this);    }	@Override	public void uncaughtException(Thread thread, Throwable ex) {		// TODO Auto-generated method stub		if( ex != null )		{			ex.printStackTrace();			Log.e( TAG, ex.getMessage().toString());		}		if (!handleException(ex) && mDefaultHandler != null) 		{			//如果用户没有处理则让系统默认的异常处理器来处理			mDefaultHandler.uncaughtException(thread, ex);		} 		else 		{			//收集设备参数信息 			collectDeviceInfo(mContext);			//保存日志文件 			String local = saveCrashInfo2File(ex);						if( local != null )			{				//LogUploadThread lpThread = new LogUploadThread( mContext, local );				//lpThread.start();			}		}	}	/**	 * 初始化	 * 	 * @param context	 */	public void init(Context context) 	{		mContext = context;		//获取系统默认的UncaughtException处理器		mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();		//设置该CrashHandler为程序的默认处理器		Thread.setDefaultUncaughtExceptionHandler(this);	}		/**	 * 自定义错误处理,收集错误信息 发送错误报告等操作均在此完成.	 * 	 * @param ex	 * @return true:如果处理了该异常信息;否则返回false.	 */	private boolean handleException(Throwable ex) 	{		if (ex == null) 		{			return false;		}		return true;	}		/**	 * 收集设备参数信息	 * @param ctx	 */	private void collectDeviceInfo(Context ctx) 	{		try 		{			PackageManager pm = ctx.getPackageManager();			PackageInfo pi = pm.getPackageInfo(ctx.getPackageName(), PackageManager.GET_ACTIVITIES);			if (pi != null) {				String versionName = pi.versionName == null ? "null" : pi.versionName;				String versionCode = pi.versionCode + "";				infos.put("versionName", versionName);				infos.put("versionCode", versionCode);			}		} 		catch (NameNotFoundException e) 		{			Log.e(TAG, "an error occured when collect package info", e);		}		Field[] fields = Build.class.getDeclaredFields();		for (Field field : fields) 		{			try 			{				field.setAccessible(true);				infos.put(field.getName(), field.get(null).toString());				//Log.d(TAG, field.getName() + " : " + field.get(null));			} 			catch (Exception e) 			{				Log.e(TAG, "an error occured when collect crash info", e);			}		}	}	/**	 * 保存错误信息到文件中	 * 	 * @param ex	 * @return	返回文件名称,便于将文件传送到服务器	 */	private String saveCrashInfo2File(Throwable ex) 	{		StringBuffer sb = new StringBuffer();		for (Map.Entry<String, String> entry : infos.entrySet()) {			String key = entry.getKey();			String value = entry.getValue();			sb.append(key + "=" + value + "\n");		}				Writer writer = new StringWriter();		PrintWriter printWriter = new PrintWriter(writer);		ex.printStackTrace(printWriter);		Throwable cause = ex.getCause();		while (cause != null) {			cause.printStackTrace(printWriter);			cause = cause.getCause();		}		printWriter.close();		String result = writer.toString();		sb.append(result);		try 		{			long timestamp = System.currentTimeMillis();			String time = formatter.format(new Date());			String fileName = "crash-" + time + "-" + timestamp + ".log";			String path = Environment.getExternalStorageDirectory().getPath()+"/ebook/log/";			if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) 			{				File dir = new File(path);				if (!dir.exists()) 				{					dir.mkdirs();				}				FileOutputStream fos = new FileOutputStream(path + fileName);				fos.write(sb.toString().getBytes());				fos.close();			}			return (path + fileName);		} 		catch (Exception e) 		{			Log.e(TAG, "an error occured while writing file...", e);		}				return null;	}}